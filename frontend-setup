ğŸ”— React (Vite) + Spring Boot Integration â€” Step-by-Step
-----------------------------------------------------------
ğŸ§  High-Level Flow (Understand First)
-------------------------------------------------
React (localhost:5173)
   â†“ HTTP (Axios / Fetch)
Spring Cloud Gateway (localhost:5555)
   â†“
Auth / Property / Other Microservices

âœ… STEP 1: Confirm Backend Is Working (VERY IMPORTANT)

Before touching React, verify backend APIs.

ğŸ” Test using Postman / Browser

Example:

POST http://localhost:5555/auth/api/v1/auth/login


Expected:

Status: 200 OK

Response contains JWT token

âš ï¸ If backend doesnâ€™t work here â†’ frontend will never work

âœ… STEP 2: Enable CORS in Backend (Spring Boot / Gateway)
âœ”ï¸ Gateway (Best place for CORS)
server:
  port: 5555

spring:
  application:
    name: api-gateway-1

  cloud:
    gateway:
      routes:
        - id: authservice-api
          uri: lb://AUTH-SERVICE
          predicates:
            - Path=/auth/**
          filters:
            - RewritePath=/auth/(?<segment>.*), /${segment}

      globalcors:
        cors-configurations:
          '[/**]':
            allowed-origins:
              - http://localhost:5173
            allowed-methods:
              - GET
              - POST
              - PUT
              - DELETE
              - OPTIONS
            allowed-headers: "*"
            allow-credentials: true


ğŸ§  Focus:

Frontend origin must match exactly (5173)

Gateway handles CORS â†’ microservices stay clean

âœ… STEP 3: Create React Project Using Vite
npm create vite@latest my-react-app
cd my-react-app
npm install
npm run dev


Runs at:

http://localhost:5173

âœ… STEP 4: Install Axios (Standard in Industry)
npm install axios

âœ… STEP 5: Create Axios Configuration (IMPORTANT)

ğŸ“ src/api/axiosConfig.js

import axios from "axios";

const api = axios.create({
  baseURL: "http://localhost:5555/auth", // Gateway URL
  withCredentials: true,
});

// Attach JWT automatically
api.interceptors.request.use(config => {
  const token = localStorage.getItem("token");
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

export default api;


ğŸ¯ Why this matters

Centralized API config

JWT automatically added

Clean code everywhere else

âœ… STEP 6: Call Backend from React (Login Example)

ğŸ“ src/components/Login.jsx

import { useState } from "react";
import api from "../api/axiosConfig";

function Login() {
  const [username, setUsername] = useState("");
  const [password, setPassword] = useState("");

  const handleLogin = async () => {
    try {
      const res = await api.post("/api/v1/auth/login", {
        username,
        password
      });

      console.log("JWT Token:", res.data.data);
      localStorage.setItem("token", res.data.data);

      alert("Login successful");
    } catch (err) {
      console.error(err);
      alert("Login failed");
    }
  };

  return (
    <div>
      <input placeholder="Username" onChange={e => setUsername(e.target.value)} />
      <input type="password" placeholder="Password" onChange={e => setPassword(e.target.value)} />
      <button onClick={handleLogin}>Login</button>
    </div>
  );
}

export default Login;

âœ… STEP 7: Verify Connection (VERY IMPORTANT)
ğŸ” Browser DevTools

Open Network tab

Click Login

Check:

Request URL â†’ http://localhost:5555/auth/...

Status â†’ 200

Response â†’ JWT token

ğŸ” Check Token
localStorage.getItem("token");


âœ” If token exists â†’ connection successful

âœ… STEP 8: Call Secured API (JWT Validation)

Example:

api.get("/api/v1/user/profile")
  .then(res => console.log(res.data))
  .catch(err => console.error(err));


Backend:

@PreAuthorize("hasRole('USER')")
@GetMapping("/profile")
public User profile() { ... }

âœ… STEP 9: Common Errors & Fixes (INTERVIEW GOLD)
Error	Cause	Fix
404	Wrong path	Match gateway rewrite path
CORS error	Missing config	Add gateway CORS
401	Token missing	Axios interceptor
ERR_CONNECTION_REFUSED	Backend down	Start Gateway
Token not visible	Wrong response field	console.log(res.data)
âœ… STEP 10: Production Best Practices (VERY IMPORTANT)

âœ” Use .env

VITE_API_BASE_URL=http://localhost:5555/auth


âœ” Update axios:

baseURL: import.meta.env.VITE_API_BASE_URL


âœ” Never hardcode URLs

ğŸ¯ WHAT TO FOCUS ON (EXAM / INTERVIEW)

âœ… Gateway handles CORS
âœ… Axios interceptor for JWT
âœ… Token stored in localStorage
âœ… Frontend only talks to Gateway
âœ… Proper error handling

ğŸ”¥ Interview Answer (You Can Say This)
â€œWe connect React with Spring Boot through a centralized API Gateway.
React uses Axios with interceptors to attach JWT tokens.
CORS is handled at the gateway level, and secure APIs are accessed using Bearer tokens.â€
==========================================================================================================================================


ğŸ” 1ï¸âƒ£ Protected Routes in React (JWT Based)
ğŸ¯ Goal

Prevent access to pages unless the user is logged in.

âœ… Step 1: Create Auth Utility

ğŸ“ src/utils/auth.js

export const isAuthenticated = () => {
  return !!localStorage.getItem("token");
};

export const getUserRole = () => {
  const token = localStorage.getItem("token");
  if (!token) return null;

  const payload = JSON.parse(atob(token.split(".")[1]));
  return payload.role;
};

âœ… Step 2: Create ProtectedRoute Component

ğŸ“ src/routes/ProtectedRoute.jsx

import { Navigate } from "react-router-dom";
import { isAuthenticated } from "../utils/auth";

const ProtectedRoute = ({ children }) => {
  return isAuthenticated() ? children : <Navigate to="/login" />;
};

export default ProtectedRoute;

âœ… Step 3: Use in Routes

ğŸ“ src/App.jsx

import { BrowserRouter, Routes, Route } from "react-router-dom";
import ProtectedRoute from "./routes/ProtectedRoute";
import Dashboard from "./pages/Dashboard";
import Login from "./pages/Login";

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/login" element={<Login />} />

        <Route
          path="/dashboard"
          element={
            <ProtectedRoute>
              <Dashboard />
            </ProtectedRoute>
          }
        />
      </Routes>
    </BrowserRouter>
  );
}

export default App;


âœ” Now /dashboard is JWT-protected

ğŸ§­ 2ï¸âƒ£ Role-Based UI (ADMIN / USER)
ğŸ¯ Goal

Show UI elements based on user role.

âœ… Step 1: Decode Role from JWT

Already done:

getUserRole(); // ROLE_ADMIN or ROLE_USER

âœ… Step 2: RoleBasedRoute

ğŸ“ src/routes/RoleBasedRoute.jsx

import { Navigate } from "react-router-dom";
import { getUserRole } from "../utils/auth";

const RoleBasedRoute = ({ role, children }) => {
  const userRole = getUserRole();

  if (userRole !== role) {
    return <Navigate to="/unauthorized" />;
  }

  return children;
};

export default RoleBasedRoute;

âœ… Step 3: Use It
<Route
  path="/admin"
  element={
    <ProtectedRoute>
      <RoleBasedRoute role="ROLE_ADMIN">
        <AdminDashboard />
      </RoleBasedRoute>
    </ProtectedRoute>
  }
/>

âœ… Step 4: Role-Based UI Rendering
{getUserRole() === "ROLE_ADMIN" && (
  <button>Delete Property</button>
)}


âœ” UI + route + backend all secured

ğŸ§ª 3ï¸âƒ£ End-to-End Auth Flow Diagram (VERY IMPORTANT)
ğŸ” Complete Flow
[ React (Vite) ]
        |
        | 1ï¸âƒ£ Login Request (username, password)
        â†“
[ API Gateway :5555 ]
        |
        â†“
[ Auth Service ]
        |
        | 2ï¸âƒ£ Validate User
        | 3ï¸âƒ£ Generate JWT
        â†“
[ JWT Token Returned ]
        |
        â†“
[ React ]
  - Store token in localStorage
  - Attach token via Axios Interceptor
        |
        | 4ï¸âƒ£ Secured API Call
        â†“
[ API Gateway ]
        |
        | 5ï¸âƒ£ JWT Filter Validation
        â†“
[ Microservice ]
        |
        | 6ï¸âƒ£ Return Secured Data
        â†“
[ React UI Updated ]

ğŸ§  Key Security Points

âœ” Password hashed (BCrypt)
âœ” JWT stateless
âœ” Gateway validates token
âœ” Role-based authorization

ğŸš€ 4ï¸âƒ£ Deploy React + Spring Boot (PRODUCTION READY)
ğŸ”µ OPTION 1: React + Spring Boot on Same Server (Recommended)
âœ… Step 1: Build React App
npm run build


Output:

dist/

âœ… Step 2: Copy React Build to Spring Boot
spring-boot-app
 â””â”€â”€ src/main/resources/static
     â””â”€â”€ index.html
     â””â”€â”€ assets/

âœ… Step 3: Configure Controller
@Controller
public class FrontendController {

  @GetMapping("/{path:[^\\.]*}")
  public String forward() {
    return "forward:/index.html";
  }
}


âœ” Single deployment
âœ” Same domain
âœ” No CORS issues

ğŸ”µ OPTION 2: Separate Deployment (Cloud)
ğŸ”¹ React

Netlify / Vercel / AWS S3

ğŸ”¹ Backend

AWS EC2 / Docker / Kubernetes

Update .env:

VITE_API_BASE_URL=https://api.myapp.com/auth

ğŸ³ Docker (Industry Standard)
React Dockerfile
FROM node:18
WORKDIR /app
COPY . .
RUN npm install && npm run build
CMD ["npx", "serve", "dist"]

Spring Boot Dockerfile
FROM openjdk:17
COPY target/app.jar app.jar
ENTRYPOINT ["java","-jar","/app.jar"]

ğŸ¯ FINAL INTERVIEW SUMMARY (MEMORIZE THIS)

â€œWe secure React routes using ProtectedRoute and RoleBasedRoute.
JWT is stored in localStorage and attached via Axios interceptors.
Authorization is enforced both on frontend UI and backend APIs. 
The API Gateway validates tokens. For deployment, React is either bundled inside Spring Boot or deployed separately using Docker.â€
